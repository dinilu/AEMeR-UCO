{
  "hash": "94b73717ab2f74456bb538e09372f2ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelos Jerárquicos de Comunidades de Especies en R\"\nsubtitle: \"Hierarchical Models of Species Communities (HMSC)\"\nauthor: \"Diego Nieto Lugilde\"\ndate: 10/18/2024\ninstitute: \"Universidad de Córdoba (España)\"\nslide-number: true\nformat:\n  revealjs:\n    logo: img/logos.png\n    footer: \"[AEMeR](https://dnietolugilde.com/AEMeR)\"\n    scrollable: true\n    chalkboard: true\ninclude-in-header: \n  text: |\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC\" crossorigin=\"anonymous\">\nlightbox: auto\neditor: source\n---\n\n\n\n## Cargamos algunos datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(openxlsx)\nenv <- read.xlsx(\"data/sciberras_ambiente.xlsx\", sheet = 1, rowNames = TRUE)\ncom <- read.xlsx(\"data/sciberras_especies.xlsx\", sheet = 1, rowNames = TRUE)\n```\n:::\n\n\n\n## Preparamos un poco los datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm <- as.matrix(com)\n\nenvm <- scale(env[, 4:7])\nenvm <- as.data.frame(envm)\n\nsites <- env[, 1:3]\n```\n:::\n\n\n\n## Simulamos unos datos filogenéticos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphy <- ape::rcoal(n = ncol(comm), \n                 tip.label = colnames(comm), \n                 br = \"coalescent\")\nplot(phy, no.margin = TRUE)\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n\n## Definimos el diseño experimental\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Hmsc)\nstudyDesign <- data.frame(rio = as.factor(sites$rio),\n                         mes = as.factor(sites$mes))\nrioL <- HmscRandomLevel(units = levels(sites$rio))\nmesL <- HmscRandomLevel(units = levels(sites$mes))\n\nrioL$nfMin <- 2\nmesL$nfMin <- 2\n```\n:::\n\n\n\n## Especificamos la estructura del modelo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm0 <- Hmsc(Y = comm, \n         XData = envm, \n         XFormula = ~1,\n         studyDesign = studyDesign, \n         ranLevels = list(rio = rioL, mes = mesL),\n         distr = \"lognormal poisson\")\n\nm1 <- Hmsc(Y = comm, \n           XData = envm,\n           XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE) + salinidad + ph,\n           distr = \"lognormal poisson\")\n\n\nm_env <- Hmsc(Y = comm, \n          XData = envm,\n          XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE)  + salinidad + ph,\n          studyDesign = studyDesign, \n          ranLevels = list(rio = rioL, mes = mesL),\n          distr = \"lognormal poisson\")\n\nm_env_phy <- Hmsc(Y = comm,\n         XData = envm, \n         XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE)  + salinidad + ph,\n         phyloTree = phy,\n         studyDesign = studyDesign, \n         ranLevels = list(rio = rioL, mes = mesL),\n         distr = \"lognormal poisson\")\n```\n:::\n\n\n\n## Definimos los parámetros para las Cadenas de Markov Monte Carlo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- 100 # Este valor debería ser más alto. Del orden de 100000 hacia arriba.\nthin <- 1 # Este valor también suele ser más alto. Del orden de 50-100 hacia arriba.\ntransient <- 500*thin\nnChains <- 4\n```\n:::\n\n\n\n## Se calibran y estiman los parámetros del modelos con las MCMC\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm0 <- sampleMcmc(m0, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm1 <- sampleMcmc(m1, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm_env <- sampleMcmc(m_env, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm_env_phy <- sampleMcmc(m_env_phy, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\n```\n:::\n\n\n\n## Convertimos los resultados en objetos CODA, son un tipo de datos de análisis bayesianos en R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpost_m0 <- convertToCodaObject(m0)\nmpost_m1 <- convertToCodaObject(m1)\nmpost_m_env <- convertToCodaObject(m_env)\nmpost_m_env_phy <- convertToCodaObject(m_env_phy)\n```\n:::\n\n\n\n## Calculamos dos estadísticos de calibración de MCMC\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nes_m0 <- effectiveSize(mpost_m0$Beta)\nes_m1 <- effectiveSize(mpost_m1$Beta)\nes_m_env <- effectiveSize(mpost_m_env$Beta)\nes_m_env_phy <- effectiveSize(mpost_m_env_phy$Beta)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngd_m0 <- gelman.diag(mpost_m0$Beta, multivariate=FALSE)$psrf\ngd_m_env <- gelman.diag(mpost_m_env$Beta, multivariate=FALSE)$psrf\ngd_m_env_phy <- gelman.diag(mpost_m_env_phy$Beta, multivariate=FALSE)$psrf\n```\n:::\n\n\n\n## Dibujamos las gráficas de esos dos parámetros\n\nEffective size debería estar entorno al número de muestras de las MCMC (samples * nChains). El diagnóstico de Gelman debería estar entorno a 1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\nhist(es_m0, main=\"ess(beta)\")\nhist(gd_m0, main=\"psrf(beta)\")\nhist(es_m_env, main=\"ess(beta)\")\nhist(gd_m_env, main=\"psrf(beta)\")\nhist(es_m_env_phy, main=\"ess(beta)\")\nhist(gd_m_env_phy, main=\"psrf(beta)\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n\n## ... lo mismo pero con los valores de Omega, que son los coeficientes de interacciones entre especies\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\nhist(effectiveSize(mpost_m0$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m0$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\nhist(effectiveSize(mpost_m_env$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m_env$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\nhist(effectiveSize(mpost_m_env_phy$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m_env_phy$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n\n## Tambien podemos dibujar algunas de las cadenas para visulizar su forma y ver si se han estabilizado\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpost_m0$Beta[[1]][,2])\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n\n\n## Para evaluar el modelo en términos de la distribución/abundancia de las especies, debemos hacer predicciones primero.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m0 <- computePredictedValues(m0)\nevaluateModelFit(hM = m0, predY = preds_m0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 170.9160646 113.0408709  19.9874220  26.2796508   1.4684007   1.2386831\n [7]   0.2528701   0.5603234   0.2844172   0.2494173\n\n$SR2\n [1]  0.4100011564  0.4279812382  0.1562166610  0.3115945422  0.0006877564\n [6]  0.0657174961 -0.0211682746 -0.0463958771 -0.0016832971 -0.0091412386\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1]  0.31280448  0.35544222 -0.00145036  0.10073745  0.28521127          NA\n [7]          NA          NA          NA          NA\n\n$C.RMSE\n [1] 209.3191795 135.5270404  44.7413177  42.8196020   3.4705667   5.6457716\n [7]   0.7880865   0.4455791   0.7674621   0.7916367\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m1 <- computePredictedValues(m1)\nevaluateModelFit(hM = m1, predY = preds_m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 206.2598320 146.6480880  19.7492154  24.9819356   1.4587215   1.2087098\n [7]   0.5006536   0.3417060   0.5852146   0.2469946\n\n$SR2\n [1]  0.2134741261  0.2830001699  0.0409779324  0.1614505749 -0.0016364935\n [6]  0.0093395061 -0.0521911663  0.0033730159  0.0014122316  0.0002760524\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.15117442 0.13313732 0.16433161 0.02566646 0.34965035 1.00000000\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 250.2225119 173.0128339  44.0950234  40.5371826   3.3873281   5.7708450\n [7]   0.7692517   0.7393636   0.5556199   0.7883110\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m_env <- computePredictedValues(m_env)\nevaluateModelFit(hM = m_env, predY = preds_m_env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 204.6395501 107.5342530  19.3972167  24.5422584   1.4653792   1.2047814\n [7]   0.4648701   0.3008021   0.2597395   0.2052706\n\n$SR2\n [1]  0.294020274  0.483596977  0.135766625  0.374054521  0.002925094\n [6]  0.032644889 -0.017667357  0.015126050 -0.043429038  0.041425121\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.24137154 0.33106850 0.21615568 0.26218852 0.09720858 1.00000000\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 249.3483777 129.0059641  43.3830982  40.8172092   3.4166134   5.7526462\n [7]   0.8060446   0.7747066   0.9246509   0.7180132\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m_env_phy <- computePredictedValues(m_env_phy)\nevaluateModelFit(hM = m_env_phy, predY = preds_m_env_phy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 249.3159117 118.8646725  19.6978663  24.7985204   1.4434328   1.2116417\n [7]   0.2378420   0.2134778   0.5379523   0.3162107\n\n$SR2\n [1]  0.2872404992  0.4594733396  0.1545266736  0.3073478796 -0.0018206885\n [6]  0.0167070345  0.0001552795  0.0315592904  0.0315592904  0.0049861974\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.19096755 0.30340799 0.25851189 0.06978467 0.12587413 1.00000000\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 302.2992785 142.4983385  44.1984681  39.7219240   3.4211344   5.7171843\n [7]   0.8105228   0.8594665   0.4117646   0.6479560\n```\n\n\n:::\n:::\n\n\n\n## También es posible realizar evaluación por validación cruzada\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npartition_env <- createPartition(m_env, nfolds = 4)\npreds_m_env = computePredictedValues(m_env, \n                               partition = partition_env,\n                               nParallel = nChains)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCross-validation, fold 1 out of 4\nCross-validation, fold 2 out of 4\nCross-validation, fold 3 out of 4\nCross-validation, fold 4 out of 4\n```\n\n\n:::\n\n```{.r .cell-code}\nevaluateModelFit(hM = m_env, predY = preds_m_env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 214.8840647 245.1848667  19.8995694  27.9810750   1.5122591   1.6239692\n [7]   0.2357099   0.2470956   0.2729051   0.3088260\n\n$SR2\n [1]  1.433957e-01  1.650115e-01  5.509319e-02  1.421574e-01 -3.499925e-03\n [6] -2.649303e-05  5.590062e-03  9.453782e-04 -5.648926e-03  4.665286e-02\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1]  0.077254538  0.049999057  0.045367043  0.009106176 -0.118360978\n [6] -1.000000000           NA           NA           NA           NA\n\n$C.RMSE\n [1] 261.6627433 291.1351402  44.2905333  42.6515808   3.5739678   5.9336715\n [7]   0.8485605   0.8517013   0.8607454   0.4994370\n```\n\n\n:::\n:::\n\n\n\n## Una vez que tengamos un modelo sólido. Nos interesa ver que papel juegan las variables ambientales en las especies/comunidades.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostBeta <- getPostEstimate(m_env, parName = \"Beta\")\nplotBeta(m_env, \n         post = postBeta, \n         param = \"Support\", \n         supportLevel = 0.9)\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n\n## También podemos ver su relación con la información filogenética, si la hemos incluido en el modelo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostBeta <- getPostEstimate(m_env_phy, parName = \"Beta\")\nplotBeta(m_env_phy, \n         post = postBeta, \n         param = \"Support\", \n         supportLevel = 0.9,\n         plotTree = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3 1.0 0.0 1.0\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n:::\n\n\n\n## Otro aspecto importante/novedoso es estimar las correlaciones entre especies\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(corrplot)\nOmegaCor <- computeAssociations(m_env)\nsupportLevel <- 0.95\ntoPlot <- ((OmegaCor[[1]]$support > supportLevel) +\n           (OmegaCor[[1]]$support < (1-supportLevel)\n            ) > 0) * OmegaCor[[1]]$mean\ncorrplot(toPlot)\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n\n## Cuando especificamos un modelo sin variables ambientales, estamos haciendo un modelo \"unconstrained\" o indirecto. Por lo que se puede usar para generar gráficos de ordenación.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\netaPost <- getPostEstimate(m0, \"Eta\")\nlambdaPost <- getPostEstimate(m0, \"Lambda\")\nbiPlot(m0, \n       etaPost = etaPost, \n       lambdaPost = lambdaPost, \n       factors = c(1,2), \n       \"ph\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n\n## En este tipo de modelos, la importancia de cada variable se mide en términos de variación explicada y se calcula con análisis de particionado de la varianza\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVP = computeVariancePartitioning(m_env)\nplotVariancePartitioning(m_env, VP = VP)\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n\n\n## Como en los Modelos de Distribución de Especies, podemos calcular curvas de respuesta de cada especie/comunidad a las variables ambientales\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGradient = constructGradient(m1, focalVariable = \"temperatura\",\nnon.focalVariables = list(\"habitat\"=list(3,\"open\")))\nGradient$XDataNew\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    temperatura   materia_org    salinidad          ph\n1  -2.065315281 -0.1667234554 -0.501380262  0.37285247\n2  -1.878146837 -0.1516142030 -0.455942859  0.33906285\n3  -1.690978393 -0.1365049507 -0.410505456  0.30527323\n4  -1.503809949 -0.1213956984 -0.365068052  0.27148361\n5  -1.316641505 -0.1062864460 -0.319630649  0.23769400\n6  -1.129473060 -0.0911771937 -0.274193245  0.20390438\n7  -0.942304616 -0.0760679413 -0.228755842  0.17011476\n8  -0.755136172 -0.0609586890 -0.183318438  0.13632514\n9  -0.567967728 -0.0458494366 -0.137881035  0.10253552\n10 -0.380799284 -0.0307401843 -0.092443632  0.06874590\n11 -0.193630840 -0.0156309320 -0.047006228  0.03495628\n12 -0.006462395 -0.0005216796 -0.001568825  0.00116666\n13  0.180706049  0.0145875727  0.043868579 -0.03262296\n14  0.367874493  0.0296968251  0.089305982 -0.06641258\n15  0.555042937  0.0448060774  0.134743386 -0.10020220\n16  0.742211381  0.0599153298  0.180180789 -0.13399182\n17  0.929379825  0.0750245821  0.225618193 -0.16778144\n18  1.116548270  0.0901338344  0.271055596 -0.20157106\n19  1.303716714  0.1052430868  0.316492999 -0.23536068\n20  1.490885158  0.1203523391  0.361930403 -0.26915030\n```\n\n\n:::\n\n```{.r .cell-code}\npredY <- predict(m1, \n                XData=Gradient$XDataNew, \n                studyDesign=Gradient$studyDesignNew,\n                ranLevels=Gradient$rLNew, \n                expected=TRUE)\nplotGradient(m1, Gradient, pred=predY, measure=\"S\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9675\n```\n\n\n:::\n\n```{.r .cell-code}\nplotGradient(m1, Gradient, pred=predY, measure=\"Y\", index = 3)\n```\n\n::: {.cell-output-display}\n![](AEMER-5_HMSC_files/figure-revealjs/unnamed-chunk-24-2.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.99\n```\n\n\n:::\n:::",
    "supporting": [
      "AEMER-5_HMSC_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}