{
  "hash": "94b73717ab2f74456bb538e09372f2ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelos Jerárquicos de Comunidades de Especies en R\"\nsubtitle: \"Hierarchical Models of Species Communities (HMSC)\"\nauthor: \"Diego Nieto Lugilde\"\ndate: 10/18/2024\ninstitute: \"Universidad de Córdoba (España)\"\nslide-number: true\nformat:\n  revealjs:\n    logo: img/logos.png\n    footer: \"[AEMeR](https://dnietolugilde.com/AEMeR)\"\n    scrollable: true\n    chalkboard: true\ninclude-in-header: \n  text: |\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC\" crossorigin=\"anonymous\">\nlightbox: auto\neditor: source\n---\n\n\n\n## Cargamos algunos datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(openxlsx)\nenv <- read.xlsx(\"data/sciberras_ambiente.xlsx\", sheet = 1, rowNames = TRUE)\ncom <- read.xlsx(\"data/sciberras_especies.xlsx\", sheet = 1, rowNames = TRUE)\n```\n:::\n\n\n\n## Preparamos un poco los datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomm <- as.matrix(com)\n\nenvm <- scale(env[, 4:7])\nenvm <- as.data.frame(envm)\n\nsites <- env[, 1:3]\n```\n:::\n\n\n\n## Simulamos unos datos filogenéticos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphy <- ape::rcoal(n = ncol(comm), \n                 tip.label = colnames(comm), \n                 br = \"coalescent\")\nplot(phy, no.margin = TRUE)\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n\n## Definimos el diseño experimental\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Hmsc)\nstudyDesign <- data.frame(rio = as.factor(sites$rio),\n                         mes = as.factor(sites$mes))\nrioL <- HmscRandomLevel(units = levels(sites$rio))\nmesL <- HmscRandomLevel(units = levels(sites$mes))\n\nrioL$nfMin <- 2\nmesL$nfMin <- 2\n```\n:::\n\n\n\n## Especificamos la estructura del modelo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm0 <- Hmsc(Y = comm, \n         XData = envm, \n         XFormula = ~1,\n         studyDesign = studyDesign, \n         ranLevels = list(rio = rioL, mes = mesL),\n         distr = \"lognormal poisson\")\n\nm1 <- Hmsc(Y = comm, \n           XData = envm,\n           XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE) + salinidad + ph,\n           distr = \"lognormal poisson\")\n\n\nm_env <- Hmsc(Y = comm, \n          XData = envm,\n          XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE)  + salinidad + ph,\n          studyDesign = studyDesign, \n          ranLevels = list(rio = rioL, mes = mesL),\n          distr = \"lognormal poisson\")\n\nm_env_phy <- Hmsc(Y = comm,\n         XData = envm, \n         XFormula = ~materia_org + poly(temperatura ,degree = 2, raw = TRUE)  + salinidad + ph,\n         phyloTree = phy,\n         studyDesign = studyDesign, \n         ranLevels = list(rio = rioL, mes = mesL),\n         distr = \"lognormal poisson\")\n```\n:::\n\n\n\n## Definimos los parámetros para las Cadenas de Markov Monte Carlo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- 100 # Este valor debería ser más alto. Del orden de 100000 hacia arriba.\nthin <- 1 # Este valor también suele ser más alto. Del orden de 50-100 hacia arriba.\ntransient <- 500*thin\nnChains <- 4\n```\n:::\n\n\n\n## Se calibran y estiman los parámetros del modelos con las MCMC\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm0 <- sampleMcmc(m0, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm1 <- sampleMcmc(m1, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm_env <- sampleMcmc(m_env, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\nm_env_phy <- sampleMcmc(m_env_phy, \n               thin = thin, \n               samples = samples, \n               transient = transient, \n               nChains = nChains, \n               nParallel = nChains)\n```\n:::\n\n\n\n## Convertimos los resultados en objetos CODA, son un tipo de datos de análisis bayesianos en R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpost_m0 <- convertToCodaObject(m0)\nmpost_m1 <- convertToCodaObject(m1)\nmpost_m_env <- convertToCodaObject(m_env)\nmpost_m_env_phy <- convertToCodaObject(m_env_phy)\n```\n:::\n\n\n\n## Calculamos dos estadísticos de calibración de MCMC\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nes_m0 <- effectiveSize(mpost_m0$Beta)\nes_m1 <- effectiveSize(mpost_m1$Beta)\nes_m_env <- effectiveSize(mpost_m_env$Beta)\nes_m_env_phy <- effectiveSize(mpost_m_env_phy$Beta)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngd_m0 <- gelman.diag(mpost_m0$Beta, multivariate=FALSE)$psrf\ngd_m_env <- gelman.diag(mpost_m_env$Beta, multivariate=FALSE)$psrf\ngd_m_env_phy <- gelman.diag(mpost_m_env_phy$Beta, multivariate=FALSE)$psrf\n```\n:::\n\n\n\n## Dibujamos las gráficas de esos dos parámetros\n\nEffective size debería estar entorno al número de muestras de las MCMC (samples * nChains). El diagnóstico de Gelman debería estar entorno a 1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\nhist(es_m0, main=\"ess(beta)\")\nhist(gd_m0, main=\"psrf(beta)\")\nhist(es_m_env, main=\"ess(beta)\")\nhist(gd_m_env, main=\"psrf(beta)\")\nhist(es_m_env_phy, main=\"ess(beta)\")\nhist(gd_m_env_phy, main=\"psrf(beta)\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n\n## ... lo mismo pero con los valores de Omega, que son los coeficientes de interacciones entre especies\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(3,2))\nhist(effectiveSize(mpost_m0$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m0$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\nhist(effectiveSize(mpost_m_env$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m_env$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\nhist(effectiveSize(mpost_m_env_phy$Omega[[1]]), main=\"ess(omega)\")\nhist(gelman.diag(mpost_m_env_phy$Omega[[1]], multivariate=FALSE)$psrf, main=\"psrf(omega)\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n\n## Tambien podemos dibujar algunas de las cadenas para visulizar su forma y ver si se han estabilizado\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(mpost_m0$Beta[[1]][,2])\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n:::\n\n\n\n## Para evaluar el modelo en términos de la distribución/abundancia de las especies, debemos hacer predicciones primero.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m0 <- computePredictedValues(m0)\nevaluateModelFit(hM = m0, predY = preds_m0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 176.1891390 113.3819140  19.9669428  25.7011014   1.4737596   1.2348385\n [7]   0.6480730   0.3811005   0.4564347   0.6587788\n\n$SR2\n [1]  0.356940712  0.430461312  0.128924738  0.322763592 -0.002164043\n [6]  0.037958426  0.021168275 -0.011233670 -0.012729935  0.024952644\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.29267547 0.37953646 0.06156373 0.18173214 0.03169014         NA\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 213.9207373 135.6517973  44.6541693  42.3680914   3.4559702   5.7187362\n [7]   0.3292153   0.6491780   0.5500465   0.3267268\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m1 <- computePredictedValues(m1)\nevaluateModelFit(hM = m1, predY = preds_m1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 441.2060688 124.0995733  19.4937653  26.4232928   1.4626281   1.2348022\n [7]   0.3640992   0.2967474   0.2244434   0.3159712\n\n$SR2\n [1]  0.204591288  0.278270496  0.054234927  0.174222286  0.014584948\n [6]  0.002483611  0.000431332  0.016853408  0.016853408 -0.001397516\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.14628186 0.14101741 0.14107897 0.01455414 0.01528637 1.00000000\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 524.8324792 146.1360562  43.4599196  41.0280928   3.4745828   5.7682407\n [7]   0.6688393   0.7343398   0.7696891   0.7293591\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m_env <- computePredictedValues(m_env)\nevaluateModelFit(hM = m_env, predY = preds_m_env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 214.2521043 130.1587942  19.5863620  25.1591691   1.4526257   1.2341329\n [7]   0.2062596   0.2163149   0.2065560   0.2045055\n\n$SR2\n [1]  0.353709265  0.465359210  0.105966862  0.356189004  0.004750754\n [6]  0.016176588  0.002915804  0.003373016  0.005147059 -0.022360248\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1]  0.28616426  0.30685626  0.22043589  0.14748104  0.01155869 -0.25000000\n [7]          NA          NA          NA          NA\n\n$C.RMSE\n [1] 262.2170394 156.1560598  43.8217146  41.5482601   3.4437496   5.8868526\n [7]   0.8418953   0.8935774   0.9144335   0.9133166\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_m_env_phy <- computePredictedValues(m_env_phy)\nevaluateModelFit(hM = m_env_phy, predY = preds_m_env_phy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 184.9757296 117.7430132  19.7549442  24.9857485   1.4323117   1.2353708\n [7]   0.2653488   0.2863802   0.2716157   0.4667680\n\n$SR2\n [1]  0.3622176245  0.4436959604  0.1096460500  0.3544545857  0.0018604838\n [6]  0.0906223152 -0.0008454106  0.0303571429 -0.0134920635 -0.0006211180\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1] 0.28678724 0.29074706 0.18736919 0.08262324 0.34965035 1.00000000\n [7]         NA         NA         NA         NA\n\n$C.RMSE\n [1] 226.7265646 140.8851609  44.3244918  41.4678534   3.3803274   5.5956194\n [7]   0.7923804   0.7004086   0.8523164   0.6153267\n```\n\n\n:::\n:::\n\n\n\n## También es posible realizar evaluación por validación cruzada\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npartition_env <- createPartition(m_env, nfolds = 4)\npreds_m_env = computePredictedValues(m_env, \n                               partition = partition_env,\n                               nParallel = nChains)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCross-validation, fold 1 out of 4\nCross-validation, fold 2 out of 4\nCross-validation, fold 3 out of 4\nCross-validation, fold 4 out of 4\n```\n\n\n:::\n\n```{.r .cell-code}\nevaluateModelFit(hM = m_env, predY = preds_m_env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$RMSE\n [1] 282.8160115 212.8376929  19.7716179  28.9426512   1.4990442   1.2413768\n [7]   0.2021352   0.3413352   0.2547289   0.2011618\n\n$SR2\n [1]  0.091806450  0.229641471  0.009505440  0.109193022 -0.001130670\n [6]  0.001379109  0.012577640 -0.078478058  0.001412232  0.004416839\n\n$O.AUC\n [1] 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5\n\n$O.TjurR2\n [1] 0 0 0 0 0 0 0 0 0 0\n\n$O.RMSE\n [1] 0.5814019 0.5566499 0.8960005 0.8049145 0.9115843 0.9786452 0.9858149\n [8] 0.9786452 0.9786452 0.9858149\n\n$C.SR2\n [1]  0.075517452  0.099412806  0.034414750 -0.003949079  0.029590244\n [6]  0.250000000           NA           NA           NA           NA\n\n$C.RMSE\n [1] 335.9812009 254.1607911  43.9448462  44.2574649   3.5478285   5.8558098\n [7]   0.8159360   0.9492204   0.8377288   0.8691425\n```\n\n\n:::\n:::\n\n\n\n## Una vez que tengamos un modelo sólido. Nos interesa ver que papel juegan las variables ambientales en las especies/comunidades.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostBeta <- getPostEstimate(m_env, parName = \"Beta\")\nplotBeta(m_env, \n         post = postBeta, \n         param = \"Support\", \n         supportLevel = 0.9)\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n\n## También podemos ver su relación con la información filogenética, si la hemos incluido en el modelo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npostBeta <- getPostEstimate(m_env_phy, parName = \"Beta\")\nplotBeta(m_env_phy, \n         post = postBeta, \n         param = \"Support\", \n         supportLevel = 0.9,\n         plotTree = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3 1.0 0.0 1.0\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n:::\n\n\n\n## Otro aspecto importante/novedoso es estimar las correlaciones entre especies\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(corrplot)\nOmegaCor <- computeAssociations(m_env)\nsupportLevel <- 0.95\ntoPlot <- ((OmegaCor[[1]]$support > supportLevel) +\n           (OmegaCor[[1]]$support < (1-supportLevel)\n            ) > 0) * OmegaCor[[1]]$mean\ncorrplot(toPlot)\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-21-1.png){width=960}\n:::\n:::\n\n\n\n## Cuando especificamos un modelo sin variables ambientales, estamos haciendo un modelo \"unconstrained\" o indirecto. Por lo que se puede usar para generar gráficos de ordenación.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\netaPost <- getPostEstimate(m0, \"Eta\")\nlambdaPost <- getPostEstimate(m0, \"Lambda\")\nbiPlot(m0, \n       etaPost = etaPost, \n       lambdaPost = lambdaPost, \n       factors = c(1,2), \n       \"ph\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n\n## En este tipo de modelos, la importancia de cada variable se mide en términos de variación explicada y se calcula con análisis de particionado de la varianza\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVP = computeVariancePartitioning(m_env)\nplotVariancePartitioning(m_env, VP = VP)\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n\n\n## Como en los Modelos de Distribución de Especies, podemos calcular curvas de respuesta de cada especie/comunidad a las variables ambientales\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGradient = constructGradient(m1, focalVariable = \"temperatura\",\nnon.focalVariables = list(\"habitat\"=list(3,\"open\")))\nGradient$XDataNew\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    temperatura   materia_org    salinidad          ph\n1  -2.065315281 -0.1667234554 -0.501380262  0.37285247\n2  -1.878146837 -0.1516142030 -0.455942859  0.33906285\n3  -1.690978393 -0.1365049507 -0.410505456  0.30527323\n4  -1.503809949 -0.1213956984 -0.365068052  0.27148361\n5  -1.316641505 -0.1062864460 -0.319630649  0.23769400\n6  -1.129473060 -0.0911771937 -0.274193245  0.20390438\n7  -0.942304616 -0.0760679413 -0.228755842  0.17011476\n8  -0.755136172 -0.0609586890 -0.183318438  0.13632514\n9  -0.567967728 -0.0458494366 -0.137881035  0.10253552\n10 -0.380799284 -0.0307401843 -0.092443632  0.06874590\n11 -0.193630840 -0.0156309320 -0.047006228  0.03495628\n12 -0.006462395 -0.0005216796 -0.001568825  0.00116666\n13  0.180706049  0.0145875727  0.043868579 -0.03262296\n14  0.367874493  0.0296968251  0.089305982 -0.06641258\n15  0.555042937  0.0448060774  0.134743386 -0.10020220\n16  0.742211381  0.0599153298  0.180180789 -0.13399182\n17  0.929379825  0.0750245821  0.225618193 -0.16778144\n18  1.116548270  0.0901338344  0.271055596 -0.20157106\n19  1.303716714  0.1052430868  0.316492999 -0.23536068\n20  1.490885158  0.1203523391  0.361930403 -0.26915030\n```\n\n\n:::\n\n```{.r .cell-code}\npredY <- predict(m1, \n                XData=Gradient$XDataNew, \n                studyDesign=Gradient$studyDesignNew,\n                ranLevels=Gradient$rLNew, \n                expected=TRUE)\nplotGradient(m1, Gradient, pred=predY, measure=\"S\")\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9275\n```\n\n\n:::\n\n```{.r .cell-code}\nplotGradient(m1, Gradient, pred=predY, measure=\"Y\", index = 3)\n```\n\n::: {.cell-output-display}\n![](AEMER-5-HMSC_files/figure-revealjs/unnamed-chunk-24-2.png){width=960}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.975\n```\n\n\n:::\n:::",
    "supporting": [
      "AEMER-5-HMSC_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}