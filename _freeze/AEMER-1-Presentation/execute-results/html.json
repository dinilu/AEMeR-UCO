{
  "hash": "ead8c6ac95e8fd33b6a45511f11c5017",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sesión 1: Introducción a R\"\nsubtitle: \"Análisis Espaciales y Multivariantes en R\"\nauthor: \"Diego Nieto Lugilde\"\ninstitute: \"Programa de Doctorado Recursos Naturales y Gestión Sostenible\"\nslide-number: true\nformat:\n  revealjs:\n    logo: img/R-logo.png\n    footer: \"[Análisis Espaciales y Multivariantes en R](https://dnietolugilde.com/AEMeR-UCO)\"\n    scrollable: true\n    chalkboard: true\nlightbox: auto\neditor: source\n---\n\n\n\n# El plan del curso...\n\n---\n\n* Sesión 1: Introducción a R y programación\n  + La estructura de R\n  + Funciones, objetos y programación básica\n  + Entorno (sesión de R) y directorio de trabajo\n  + Trabajar con archivos (scripts y datos)\n  + Instalación de paquetes\n  + CRAN\n  + GitHub\n  + Graficado\n* Sesión 2: Manejo de datos espaciales en R.\n  + Introducción a los datos espaciales\n  + Manejando datos espaciales \n  + Manejando datos vectoriales\n  + Manejando datos raster\n  + Graficando datos espaciales\n* Sesión 3: Análisis multivariantes en R\n  + ¿Qué son los análisis multivariantes?\n  + ¿Cuáles son los análisis multivariantes más\nfrecuentes?\n  + ¿Cómo se realizan en R?\n* Sesión 4: Modelos generalizados de disimilitud\n  + ¿Cómo funcionan los modelos generalizados de disimilitud?\n  + ¿Cómo se calibran los GDM en R?\n* Sesión 5: Modelos jerarquicos de comunidades de especies.\n  + ¿Qué son los Modelos Jerárquicos de Comunidades de Especies?\n  + ¿Cómo se calibran los HMSC en R?\n\n\n## ¿Qué es R?\n\nR es un lenguaje de programación estadística\n\n![](img/Tema_1/Código.png)\n\n# RStudio\n\nInterfaz gráfica\n\n\n# R\n\nLa línea de comandos\n  \n  \n## La estructura de R\n\n* **Funciones:** ¿qué deseas hacer?\n* **Objetos:** ¿con qué o sobre qué quieres hacerlo?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-note}\nAquí, 16 es el objeto sobre el que aplicamos la función `sqrt()` (raíz cuadrada)\n:::\n\n## La estructura de R\n\n\n\n```{dot}\ndigraph {\n\n  Objeto -> Función \n  Función -> \"Nuevo objeto\"\n\n  Función [shape=diamond];\n  rankdir=\"LR\";\n}\n```\n\n\n\n  \n## Llamar a una función\n\n* *Call*: Una función con un conjunto particular de objetos\n  + función( argumento 1 )\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-note}\nEl resultado de la función se imprime directamente en pantalla\n:::\n\n\n## Asignación de valores a objetos\n\n* *Assign*: Una función especial para crear/modificar un objeto\n  + Valor específico\n  + El resultado de una llamada a una función\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\n```\n:::\n\n\n\n:::{.callout-note}\nFijaros que el resultado no se imprime en pantalla como antes\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n## Múltiples asignaciones para crear objetos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = 10\n\na <- 10\n\n10 -> a\n```\n:::\n\n\n\n:::{callout-note}\nEstas tres líneas hacen lo mismo\n:::\n\n\n# ¿Qué información puede contener un objeto?\n\n## Números de cualquier tipo\n\n* 0, 0.2, Inf\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeric_object <- 0.5\n```\n:::\n\n\n\n\n## Caracteres (texto)\n\n* Texto libre\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncharacter_object <- \"Bromus diandrus\"\n```\n:::\n\n\n\n:::{.callout-warning}\nLas cadenas de texto se ponen entre comillas para poder usar espacios y para distinguirlos de los objetos\n:::\n\n\n## Valores lógicos\n\n* TRUE (T), FALSE (F)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_object <- TRUE\n```\n:::\n\n\n\n\n## Factores\n\n* Categorías (e.g., \"Planta\", \"Animal\", \"Hongo\")\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor_object <- factor(\"Plant\")\n```\n:::\n\n\n\n\n## No data\n\n* NA\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nna_object <- NA\n```\n:::\n\n\n\n\n## ¿Qué hace interesantes a los objetos?\n\n* Entidad con información\n* Se puede reutilizar tantas veces como se quiera\n* Pertenece a una clase, lo que le dota de propiedades propias\n* Cada clase tiene una estructura propia\n\n\n## *class()* te dice la clase de un objeto\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(numeric_object)\nclass(logical_object)\nclass(factor_object)\nclass(character_object)\nclass(\"x\")\nclass(x)\n```\n:::\n\n\n\n\n## ¿Cómo se reutilizan los objetos?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- a + 1\nb <- a * a\nx <- sqrt(b)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n\n\n## Muchas funciones aceptan varios objetos\n\n\n\n```{dot}\ndigraph {\n\n  Objeto1 -> Función \n  Objeto2 -> Función\n  Objeto3 -> Función\n  Función -> \"Nuevo objeto\"\n\n  Función [shape=diamond];\n  rankdir=\"LR\";\n}\n```\n\n\n\n\n## Se pasan varios objetos a las funciones separados por comas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(15, 16, 17, 24, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82\n```\n\n\n:::\n:::\n\n\n\n\n## Algunos objetos no son datos, si no opciones que modifican el comportamiento de las funciones\n\n\n\n```{dot}\ndigraph {\n\n  Objeto1 -> Función \n  Objeto2 -> Función\n  Objeto3 -> Función\n  Función -> \"Nuevo objeto\"\n  Opción -> Función\n\n  Función [shape=diamond];\n  Opción [shape=triangle];\n  rankdir=\"LR\";\n}\n```\n\n\n\n:::{callout-note}\nLas opciones en realidad también son objetos. El número de objetos que requiere una función se conocen como argumentos\n:::\n\n\n## Las opciones también se separan por comas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseveral_data <- c(15, 16, 17, 24, 10, NA)\nmean(several_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(several_data, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16.4\n```\n\n\n:::\n:::\n\n\n\n\n## ¿Cómo se cuales son los argumentos de una función?\n\n* Muchas funciones tendrán valores predeterminados para los argumentos\n  + Si no se especifica, el argumento tomará ese valor\n* Para encontrar estos valores y una lista de todos los argumentos, puedes usar cualquiera de las siguientes opciones:\n  + `?funcion`\n  + `help(funcion)`\n  + Usar la pestaña `Help` de Rstudio\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(mean)\n```\n:::\n\n\n\n# ¿Qué forma tienen los objetos?\n\n## Los objetos pueden tener muchos datos organizados en dimensiones\n\n![](img/Tema1/objetos_1.png)\n\n\n## Vectores numéricos\n\nSe pueden crear secuencias de números de forma sencilla\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:4\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n## Vectores numéricos\n\nSe pueden crear secuencias con la función `seq()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- seq(1, 10)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-note}\nComo veremos más adelante. Esta función es muy flexible y permite crear secuencias más complejas.\n:::\n\n## Vectores numéricos\n\nSe pueden crear secuencias de números no consecutivos con la función `c()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(4, 2, 5, 10)\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  2  5 10\n```\n\n\n:::\n:::\n\n\n\n\n## Vectores de texto y factores\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"Bromus diandrus\", \"Bromus carinatu\", \"Bison biso\")\n\nkingdom <- factor(c(\"Plant\", \"Plant\", \"Animal\"))\n```\n:::\n\n\n\n\n## Vectores lógicos\n\nOperadores condicionales: `<` `>` `<=` `>=` `==` `!=` `%in%`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n3 > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- 5\nx == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Vectores lógicos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nx < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nspecies == (\"Bromus diandrus\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Extrayendo valores de vectores\n\n* R usa [ ] para referirse a elementos de objetos\n  + V[5] devuelve el 5º elemento de un vector llamado V\n* El número entre corchetes se denomina índice (i)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(3,2,7,8)\n\na[3]\n# ????\n\na[1:3]\n# ????\n\na[seq(2, 4)]\n# ???\n```\n:::\n\n\n\n\n# Vamos a probar cosas\n\n* Ejercicios de clase\n* Parte 1: Trabajando con vectores\n\n\n# ¿Qué forma tienen los objetos?\n\n## Los objetos pueden tener muchos datos organizados en dimensiones\n\n![](img/Tema1/objetos_1.png)\n\n\n## Matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(data = 0, nrow = 6, ncol = 5)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n[3,]    0    0    0    0    0\n[4,]    0    0    0    0    0\n[5,]    0    0    0    0    0\n[6,]    0    0    0    0    0\n```\n\n\n:::\n:::\n\n\n\n\n## Matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(data = 1:30, nrow = 6, ncol = 5)\n# ????\n```\n:::\n\n\n\n\n## Extrayendo valores de matrices\n\n* R usa [ ] para referirse a elementos de objetos\n* El orden es siempre [filas, columnas]\n  + M[2,3] devuelve el elemento de la 2ª fila, 3ª columna de la matriz M\n  + M[2,] devuelve todos los elementos de la 2ª fila de la matriz M\n* Los números entre corchetes se denominan índices (i y j)\n\n\n## Extrayendo valores de matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- matrix(data = 1:30, nrow = 6, ncol = 5)\n\nA[3, 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA[c(1:3), 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19 20 21\n```\n\n\n:::\n\n```{.r .cell-code}\n# ???\n```\n:::\n\n\n\n\n## ¿Pueden los objetos mezclar tipos de datos?\n\n![](img/Tema1/objetos_2.png)\n\n\n## *Data frame*\n\n* Un data frame es una lista de vectores de la misma longitud\n* Son equivalente a matrices con diferentes tipos de datos en cada columna\n* Se usan para almacenar diferentes variables a partir de las mismas mediciones\n\n\n## *Data frame*\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n\tname = c(\"Diego\", \"Lucía\", \"Paco\"),\n\tage = c(27, 23, 24)\n\t)\n```\n:::\n\n\n\n\n## Extrayendo información de un *data frame*\n\n* Extracción de columnas\n  + `Data$columnname`\n  + `Data[,”columnname”]`\n  + `Data[,3]`\n* Nombre de filas\n  + `rownames(Data)`\n* Nombre de columnas\n  +  `colnames(Data)`\n  \n  \n# ¿Probamos cosas?\n\n* Ejercicios de clase\n* Parte 2: Trabajando con matrices y data frames\n\n\n## Archivos, objetos y proyectos\n\n> Los tres son cosas diferentes en R...\n\n:::: {.columns}\n\n::: {.column width=\"65%\"}\n* Los archivos son scripts (e.g., un archivo de texto) o archivos de datos (e.g., Excel) en el disco duro\n* Los objetos son datos en la sesión de R.  Sólo existen en la memoria temporal del ordenador\n* Un proyecto es una carpeta con un montón de archivos y objetos de R\n  + Es recomendable usar una estructura de carpetas lógica\n:::\n\n::: {.column width=\"35%\"}\n:::: {style=\"background-color: #FADA7A\"}\n* Carpeta/\n  + Datos/\n  + Figuras/\n  + Tablas/\n  + Script_1\n  + Script_2\n  + Script_3\n::::\n:::\n\n::::\n\n\n## Entorno, sesión o *environment* de R\n\n* El espacio temporal en la memoria del equipo donde R guarda objetos mientras ejecuta un análisis\n* Está limitado en tamaño por la memoria RAM del ordenador\n\n\n## Funciones útiles para controlar la sesión de trabajo\n\n* Para enumerar objetos en la sesión de R: `ls()`\n* Para eliminar objetos de la sesión de R: `rm()`\n* Para guardar la sesión de R: `save.image()`\n* Para salir de la sesión de R: `q()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\nrm(numeric_object, character_object)\nsave.image()\nrm(list=ls())\n```\n:::\n\n\n\n\n## Directorio de trabajo (= carpeta del proyecto)\n\n* Es el directorio donde R busca archivos o escribe archivos\n* En una sesión de R, las referencias a archivos se hacen desde el directorio de trabajo\n  + Es conveniente usar rutas relativas a los ficheros\n\n`getwd()` obtener el directorio de trabajo\n\n`setwd()` lo cambia\n\n## Trabajar con datos\n\n* Lectura de datos del disco duro\n* R lo almacena como un objeto (guardado en la memoria de su computadora)\n* Trata ese objeto como cualquier otro objeto\n* Los cambios en el objeto están restringidos al objeto, no afectan a los datos del disco duro\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyData <- read.csv(\"some data.csv\")\n```\n:::\n\n\n\n\n## Escribir un archivo de datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(myData, \"updated data.csv\")\n```\n:::\n\n\n\n\n## ¿Mucho más conveniente usar ficheros excel?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"openxlsx\")\nlibrary(openxlsx)\ndata <- read.xlsx(\"data\", sheet = 1)\n```\n:::\n\n\n\n\n## Scripts\n\n* Archivos de texto\n* Con llamadas a funciones (código)\n* Ordenado y secuencial:\n  + Cargar datos\n  + Modificar datos\n  + Análisis de datos\n  + Guardar/trazar resultados\n* Puede/debe contener comentarios legibles por humanos\n  + Usar # antes del comentario\n\n> No se manejan desde la consola de R, si no desde la interfaz de Rstudio.\n\n\n## Seguimos practicando\n\n* Ejercicios de clase\n* Parte 3\n\n## Ejercicios de casa (Homeworks)\t\n\n* En la web de la asignatura (enlace en Moodle)\n* Entregar antes de la siguiente clase\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}