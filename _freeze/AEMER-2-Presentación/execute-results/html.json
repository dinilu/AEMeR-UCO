{
  "hash": "2cc6d36ef6dc62a919d3bcf10a4bd1c4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Análisis de datos espaciales en R\"\nsubtitle: \"Manejo de datos espaciales en R\"\nauthor: \"Diego Nieto Lugilde\"\ndate: 10/15/2024\ninstitute: \"Universidad de Córdoba (España)\"\nslide-number: true\nformat:\n  revealjs:\n    logo: img/logos.png\n    footer: \"[AEMeR](https://dnietolugilde.com/AEMeR)\"\n    scrollable: true\n    chalkboard: true\nlightbox: auto\neditor: source\n---\n\n\n\n# Introducción a los datos espaciales\n\n## ¿Qué son los datos espaciales?\n\n![](img/datos_espaciales.jpg)\n\n## La misma información se puede representar de varias maneras\n\n:::: {.columns}\n\n::: {.column}\nAlgunos tipos de datos se ajustan mejor a ciertas formas de representación\n:::\n\n::: {.column}\n![](img/raster_versus_vectorial.jpg)\n:::\n\n::::\n\n## ¿Cómo se localiza la información?\n\n![](img/coordenadas-geograficas.jpg)\n\n## No parece fácil medir los ángulos ;)\n\n![](img/datum.jpg)\n\nSe calculan aproximaciones usando modelos de la Tierra (Datum)\n\n## No es lo mismo saber donde ocurre algo que dibujarlo en un mapa\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\nPara ello es necesario proyectar una esfera sobre un plano\n:::\n\n::: {.column width=\"60%\"}\n![](img/proyecciones.png)\n:::\n\n::::\n\n## Cada proyección y cada datum genera mapas con propiedades diferentes\n\nConformes, equidistantes, equivalentes y afiláticas\n\n![](img/tipos_de_proyecciones.jpg)\n\n# Manejando datos espaciales {background-color=\"aquamarine\"}\n\n## Vamos a usar el paquete `terra`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"terra\")\nlibrary(terra)\n```\n:::\n\n\n\n# Manejando datos vectoriales {background-color=\"aquamarine\"}\n\n## Podemos crear datos vectoriales desde cero\n\nLos más sencillos de crear son los puntos\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-2|3|4-5\"}\nlon <- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7) \nlat <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9) \nlonlat <- cbind(lon, lat) \npts <- vect(lonlat) \npts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 0  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. :  \n```\n\n\n:::\n:::\n\n\n\n:::{.callout-warning}\nFijaros que el apartado \"coord. ref.\" está vacío\n:::\n\n## Revisamos el tipo de datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SpatVector\"\nattr(,\"package\")\n[1] \"terra\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngeom(pts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      geom part      x    y hole\n [1,]    1    1 -116.7 45.3    0\n [2,]    2    1 -120.4 42.6    0\n [3,]    3    1 -116.7 38.9    0\n [4,]    4    1 -113.5 42.1    0\n [5,]    5    1 -115.5 35.7    0\n [6,]    6    1 -120.8 38.9    0\n [7,]    7    1 -119.5 36.2    0\n [8,]    8    1 -113.7 39.0    0\n [9,]    9    1 -113.7 41.6    0\n[10,]   10    1 -110.7 36.9    0\n```\n\n\n:::\n:::\n\n\n\n## Veamos la distribución espacial de los datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pts)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n## Definimos el sistema de referencia de coordenadas (CRS)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrdref <- \"+proj=longlat +datum=WGS84\"\npts <- vect(lonlat, crs = crdref)\npts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 0  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n```\n\n\n:::\n:::\n\n\n\n## Podemos comprobar el CRS de un objeto vectorial\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(pts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GEOGCRS[\\\"unknown\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ID[\\\"EPSG\\\",6326]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n        ID[\\\"EPSG\\\",8901]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"longitude\\\",east,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]],\\n        AXIS[\\\"latitude\\\",north,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433,\\n                ID[\\\"EPSG\\\",9122]]]]\"\n```\n\n\n:::\n:::\n\n\n\n## La ubicación sola no es muy interesante...\n\nVoy a simular valores de precipitación al azar (`sample`), un valor para cada punto\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2-3|4-5\"}\nprecipvalue <- sample(1:100, 10)\ndf <- data.frame(ID = 1:nrow(lonlat), \n                 precip = precipvalue)\npts <- vect(lonlat, atts = df, crs = crdref)\npts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : points \n dimensions  : 10, 2  (geometries, attributes)\n extent      : -120.8, -110.7, 35.7, 45.3  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n names       :    ID precip\n type        : <int>  <int>\n values      :     1     85\n                   2     50\n                   3     22\n```\n\n\n:::\n:::\n\n\n\n## Veamos las precipitaciones en su contexto espacial\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pts, \"precip\", type = \"interval\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n\n## Vamos a generar ahora un segundo conjunto de puntos...\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-2|3-4\"}\nlon2 <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)\nlat2 <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)\nlonlat2 <- cbind(id = c(1,1,1,1,1,1,1), part = c(1,1,1,1,1,1,1), lon2, lat2)\nlonlat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     id part   lon2 lat2\n[1,]  1    1 -116.8 41.3\n[2,]  1    1 -114.2 42.9\n[3,]  1    1 -112.9 42.4\n[4,]  1    1 -111.9 39.8\n[5,]  1    1 -114.2 37.6\n[6,]  1    1 -115.4 38.3\n[7,]  1    1 -117.7 37.6\n```\n\n\n:::\n:::\n\n\n\n## ... pero para crear datos de líneas...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlns <- vect(lonlat2, type = \"lines\", crs = crdref)\nlns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : lines \n dimensions  : 1, 0  (geometries, attributes)\n extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(lns)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n\n## ... o un datos de polígonos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npols <- vect(lonlat2, type = \"polygons\", crs = crdref)\npols\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 0  (geometries, attributes)\n extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)\n coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(pols)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n\n## Lo más normal es usar datos generados con un SIG\n\nDescargar datos de Internet (v.gr. [GADM](https://gadm.org)) y cargarlos desde el disco duro\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg <- vect(\"gadm/gadm41_ARG_1.shp\")\narg\n```\n:::\n\n\n\n## Lo más normal es usar datos generados con un SIG\n\nHay paquetes de R que dan acceso directo a datos vectoriales (v.gr. `geodata`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"geodata\")\nlibrary(geodata)\narg <- gadm(\"ARG\", level = 1, path = \".\")\narg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 24, 11  (geometries, attributes)\n extent      : -73.56056, -53.59184, -55.06153, -21.78137  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :   GID_1 GID_0   COUNTRY       NAME_1       VARNAME_1 NL_NAME_1\n type        :   <chr> <chr>     <chr>        <chr>           <chr>     <chr>\n values      : ARG.1_1   ARG Argentina Buenos Aires Baires|Buenos ~        NA\n               ARG.2_1   ARG Argentina    Catamarca              NA        NA\n               ARG.3_1   ARG Argentina        Chaco El Chaco|Presi~        NA\n    TYPE_1 ENGTYPE_1  CC_1 HASC_1 ISO_1\n     <chr>     <chr> <chr>  <chr> <chr>\n Provincia  Province    NA  AR.BA  AR-B\n Provincia  Province    NA  AR.CT  AR-K\n Provincia  Province    NA  AR.CC  AR-H\n```\n\n\n:::\n:::\n\n\n\n## Veamos si se parece a lo que conocemos...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(arg)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n\n## Estos datos se pueden guardar para no tener que volver a descargarlos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteVector(arg, \"arg.shp\", overwrite = TRUE)\n```\n:::\n\n\n\n## Comprobemos el CRS de alguno de nuestros datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\n```\n\n\n:::\n:::\n\n\n\n## Se puede borrar el CRS del conjunto de datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_sin_crs <- arg\ncrs(arg_sin_crs) <- \"\"\ncrs(arg_sin_crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\"\n```\n\n\n:::\n:::\n\n\n\n## O se puede especificar a mano (estandar PROJ.4)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_falso_utm <- arg\ncrs(arg_falso_utm) <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs\"\ncrs(arg_falso_utm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PROJCRS[\\\"unknown\\\",\\n    BASEGEOGCRS[\\\"unknown\\\",\\n        DATUM[\\\"World Geodetic System 1984\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ID[\\\"EPSG\\\",6326]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8901]]],\\n    CONVERSION[\\\"UTM zone 19S\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-69,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",10000000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]],\\n        ID[\\\"EPSG\\\",17019]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n```\n\n\n:::\n:::\n\n\n\n## O se puede especificar con los códigos [EPSG](https://epsg.io/)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_false_utm2 <- arg\ncrs(arg_false_utm2) <- \"EPSG:32719\"\ncrs(arg_false_utm2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PROJCRS[\\\"WGS 84 / UTM zone 19S\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"UTM zone 19S\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-69,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",10000000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Navigation and medium accuracy spatial referencing.\\\"],\\n        AREA[\\\"Between 72°W and 66°W, southern hemisphere between 80°S and equator, onshore and offshore. Argentina. Bolivia. Brazil. Chile. Colombia. Peru.\\\"],\\n        BBOX[-80,-72,0,-66]],\\n    ID[\\\"EPSG\\\",32719]]\"\n```\n\n\n:::\n:::\n\n\n\n## Cambia el CRS pero no las coordenadas en si\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 4))\nplot(arg)\nplot(arg_sin_crs)\nplot(arg_falso_utm)\nplot(arg_false_utm2)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-23-1.png){width=960}\n:::\n:::\n\n\n\n:::{.callout-note} \nCambia la representación gráfica porque las unidades cambian entre CRS (grados o metros). Mientras los metros se representan igual en el eje horizontal y vertical, los grados geográficos no.\n:::\n\n## Para convertir coordenadas entre diferentes CRSs tenemos que proyectar los datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2|3-6\"}\narg_utm19s <- project(arg, \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs\")\narg_4326 <- project(arg, \"EPSG:32719\")\npar(mfrow = c(1, 3))\nplot(arg)\nplot(arg_utm19s)\nplot(arg_4326)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-24-1.png){width=960}\n:::\n:::\n\n\n\n## También se puede filtrar la información para una o varias entidades de los datos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(arg$NAME_1 == \"Buenos Aires\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2|3\"}\ni <- which(arg$NAME_1 %in% c(\"Buenos Aires\", \"Río Negro\"))\ng <- arg[i,]\nplot(g)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-26-1.png){width=960}\n:::\n:::\n\n\n\n## Momento para practicar\n\nEjercicios de clase\n\nParte 1: Trabajando con datos vectoriales\n\n# Manejando datos ráster {background-color=\"aquamarine\"}\n\n## Podemos crear datos ráster desde cero\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-3|4|5\"}\nr <- rast(ncol = 10, nrow = 10, \n          xmin = -150, xmax = -80, \n          ymin = 20, ymax = 60)\nvalues(r) <- runif(ncell(r))\nr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        :       lyr.1 \nmin value   : 0.003371712 \nmax value   : 0.998414173 \n```\n\n\n:::\n:::\n\n\n\n## Veamos que aspecto tienen\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-28-1.png){width=960}\n:::\n:::\n\n\n\n## Podemos operar con los datos ráster\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2\"}\nr2 <- r * r\nr3  <- sqrt(r)\n```\n:::\n\n\n\n:::{.callout-important}\nAl operar con datos ráster, las operaciones se aplican sobre cada píxel individualmente. Por ello, sólo se pueden realizar operaciones con ráster que tienen el mismo área y el mismo tamaño de píxel. El resultado, por tanto, es un nuevo objeto ráster con las mismas características geográficas, pero cuyos píxeles tienen los valores resultantes de aplicar las funciones matemáticas.\n:::\n\n## Si trabajamos con muchas capas, mejor crear un objeto multicapa\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstck <- c(r, r2, r3)\nstck\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 10, 10, 3  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nnames       :       lyr.1,        lyr.1,      lyr.1 \nmin values  : 0.003371712, 1.136844e-05, 0.05806645 \nmax values  : 0.998414173, 9.968309e-01, 0.99920677 \n```\n\n\n:::\n:::\n\n\n\n## Veamos que aspecto tiene el objeto multicapa\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(stck)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-31-1.png){width=960}\n:::\n:::\n\n\n\n## También se pueden extraer capas de objetos multicapa\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- stck[[2]]\nr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 7, 4  (x, y)\nextent      : -150, -80, 20, 60  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \nsource(s)   : memory\nname        :        lyr.1 \nmin value   : 1.136844e-05 \nmax value   : 9.968309e-01 \n```\n\n\n:::\n:::\n\n\n\n## Como antes, lo normal es cargar datos generados en SIG\n\nPara ello podemos descargar datos de distintas fuentes (v.gr. [WorldClim](https://worldclim.org))\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntavg <- rast(\"data/tavg_arg.tif\")\ntavg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 4080, 2460, 12  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : -74, -53.5, -55.5, -21.5  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : tavg_arg.tif \nnames       : ARG_w~avg_1, ARG_w~avg_2, ARG_w~avg_3, ARG_w~avg_4, ARG_w~avg_5, ARG_w~avg_6, ... \nmin values  :       -11.1,       -11.8,       -12.5,       -14.5,       -16.7,       -19.8, ... \nmax values  :        29.2,        28.4,        27.3,        25.0,        22.2,        21.0, ... \n```\n\n\n:::\n:::\n\n\n\n## Como antes, lo normal es cargar datos generados en SIG\n\n... o podemos usar el paquete `geodata` para acceder directamente a esa información\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntavg <- worldclim_country(\"ARG\", \"tavg\", path = \".\")\ntavg\n```\n:::\n\n\n\n## Veamos si se parece a lo que conocemos...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tavg, range = c(-20, 30))\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-35-1.png){width=960}\n:::\n:::\n\n\n\n## También podemos guardar estos datos para no tener que volver a descargarlos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(tavg, \"raster_tavg_arg.tif\", overwrite = TRUE)\n```\n:::\n\n\n\n## Los datos ráster también se pueden proyectar\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntavg_utm19s <- project(tavg, \"EPSG:32719\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\ntavg_utm19s\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 4455, 2454, 12  (nrow, ncol, nlyr)\nresolution  : 871.5251, 871.5251  (x, y)\nextent      : -18378.29, 2120344, 3739870, 7622514  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 19S (EPSG:32719) \nsource      : spat_311055a7132_12560_o8up7yuDdJ6XHBX.tif \nnames       : ARG_w~avg_1, ARG_w~avg_2, ARG_w~avg_3, ARG_w~avg_4, ARG_w~avg_5, ARG_w~avg_6, ... \nmin values  :   -10.06114,   -10.70969,   -11.47373,   -13.53778,   -15.83266,   -19.14256, ... \nmax values  :    29.20000,    28.40000,    27.30000,    25.00000,    22.20000,    20.96862, ... \n```\n\n\n:::\n:::\n\n\n\n## Ahora las coordenadas si aparecen \"desplazadas\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nplot(tavg[[1]])\nplot(tavg_utm19s[[1]])\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-38-1.png){width=960}\n:::\n:::\n\n\n\n:::{.callout-warning}\nNo hay una correspondencia exacta de píxeles. Lo veréis más claro si revisáis las diapositivas anteriores (39 y 43).\n:::\n\n## Para controlar el número de pixeles y su resolución podemos crear una \"plantilla\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplantilla <- rast(tavg_utm19s)\nres(plantilla) <- 800\nplantilla\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 4853, 2673, 12  (nrow, ncol, nlyr)\nresolution  : 800, 800  (x, y)\nextent      : -18378.29, 2120022, 3739870, 7622270  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 19S (EPSG:32719) \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntavg_utm19s_plantilla <- project(tavg, plantilla)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\ntavg_utm19s_plantilla\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 4853, 2673, 12  (nrow, ncol, nlyr)\nresolution  : 800, 800  (x, y)\nextent      : -18378.29, 2120022, 3739870, 7622270  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 19S (EPSG:32719) \nsource      : spat_31107f083e09_12560_zxzxx9jyyx6UnnI.tif \nnames       : ARG_w~avg_1, ARG_w~avg_2, ARG_w~avg_3, ARG_w~avg_4, ARG_w~avg_5, ARG_w~avg_6, ... \nmin values  :   -10.77633,   -11.47463,   -12.17463,   -14.20292,   -16.40292,   -19.51049, ... \nmax values  :    29.20000,    28.40000,    27.30000,    25.00000,    22.20000,    20.94299, ... \n```\n\n\n:::\n:::\n\n\n\n## Veamos el resultado\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 3))\nplot(tavg[[2]])\nplot(tavg_utm19s[[2]])\nplot(tavg_utm19s_plantilla[[2]])\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-41-1.png){width=960}\n:::\n:::\n\n\n\n## Momento de practicar por vuestra cuenta\n\nEjercicios de clase\n\nParte 2. Manejo de datos ráster\n\n# Manipular datos espaciales {background-color=\"aquamarine\"}\n\n## Podemos dibujar los mapas en base a información de los atributos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(arg, \"NAME_1\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-42-1.png){width=960}\n:::\n:::\n\n\n\n## Podemos combinar información ráster y vectorial en el mismo gráfico\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(tavg[[1]])\nplot(arg, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-43-1.png){width=960}\n:::\n:::\n\n\n\n## También se puede extraer información de atributos para trabajar con ella\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- as.data.frame(arg)\nhead(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    GID_1 GID_0   COUNTRY                 NAME_1\n1 ARG.1_1   ARG Argentina           Buenos Aires\n2 ARG.2_1   ARG Argentina              Catamarca\n3 ARG.3_1   ARG Argentina                  Chaco\n4 ARG.4_1   ARG Argentina                 Chubut\n5 ARG.5_1   ARG Argentina Ciudad de Buenos Aires\n6 ARG.6_1   ARG Argentina                Córdoba\n                         VARNAME_1 NL_NAME_1           TYPE_1        ENGTYPE_1\n1              Baires|Buenos Ayres      <NA>        Provincia         Province\n2                             <NA>      <NA>        Provincia         Province\n3   El Chaco|Presidente Juan Peron      <NA>        Provincia         Province\n4                             <NA>      <NA>        Provincia         Province\n5 BUENOS AIRES D.F.|Capital Federa      <NA> Distrito Federal Federal District\n6                          Cordova      <NA>        Provincia         Province\n  CC_1 HASC_1 ISO_1\n1 <NA>  AR.BA  AR-B\n2 <NA>  AR.CT  AR-K\n3 <NA>  AR.CC  AR-H\n4 <NA>  AR.CH  AR-U\n5 <NA>  AR.DF  <NA>\n6 <NA>  AR.CB  <NA>\n```\n\n\n:::\n:::\n\n\n\n## O puedo extraer la información de uno sólo de los atributos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg$NAME_1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Buenos Aires\"           \"Catamarca\"              \"Chaco\"                 \n [4] \"Chubut\"                 \"Ciudad de Buenos Aires\" \"Córdoba\"               \n [7] \"Corrientes\"             \"Entre Ríos\"             \"Formosa\"               \n[10] \"Jujuy\"                  \"La Pampa\"               \"La Rioja\"              \n[13] \"Mendoza\"                \"Misiones\"               \"Neuquén\"               \n[16] \"Río Negro\"              \"Salta\"                  \"San Juan\"              \n[19] \"San Luis\"               \"Santa Cruz\"             \"Santa Fe\"              \n[22] \"Santiago del Estero\"    \"Tierra del Fuego\"       \"Tucumán\"               \n```\n\n\n:::\n\n```{.r .cell-code}\narg[, \"NAME_1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 24, 1  (geometries, attributes)\n extent      : -73.56056, -53.59184, -55.06153, -21.78137  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :       NAME_1\n type        :        <chr>\n values      : Buenos Aires\n                  Catamarca\n                      Chaco\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-warning}\nNotad que en este caso, las dos formas de extraer información no se comportan exactamente igual\n:::\n\n## También podemos extraer las características geográficas (espaciales)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- geom(arg_utm19s) \nhead(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     geom part       x       y hole\n[1,]    1    1 1084262 5487852    0\n[2,]    1    1 1084239 5487854    0\n[3,]    1    1 1084236 5487823    0\n[4,]    1    1 1084213 5487825    0\n[5,]    1    1 1084206 5487732    0\n[6,]    1    1 1084159 5487735    0\n```\n\n\n:::\n:::\n\n\n\n## Es posible incorporar información a nuestros datos vectoriales\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperim(arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6542992.70 2141772.81 1833193.58 4072812.99   75022.34 1898965.96\n [7] 1546899.19 1391962.59 1887284.93 1410538.99 1816741.56 1613964.82\n[13] 2160729.22 1272355.56 2006884.02 2829645.14 3018996.89 1897253.64\n[19] 1379291.29 3552443.52 2159600.76 1709915.38 2035550.57  814874.32\n```\n\n\n:::\n\n```{.r .cell-code}\narg$perimetro <- perim(arg)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexpanse(arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 307005689751 101325015569  99764195922 224358261357    211011750\n [6] 164663835095  88958640476  78008027779  75592720001  53125295415\n[11] 142947760813  91104159966 148772281932  29980009644  94504843837\n[16] 202539975187 155196050532  88821613819  75844534099 242892543838\n[21] 133097028860 136911867268  20884464648  22539627987\n```\n\n\n:::\n\n```{.r .cell-code}\narg$area <- expanse(arg)\n```\n:::\n\n\n\n## ¿Qué pasa si quiero borrar una columna?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg$area <- NULL\n```\n:::\n\n\n\n## A veces tenemos los datos en una tabla aparte\n\n:::{.callout-note}\nMe descargué datos del [censo poblacional del país](https://censo.gob.ar/index.php/datos_definitivos_total_pais/)\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- read.csv(\"data/c2022_tp_c_resumen.csv\", \n              header = TRUE, \n              encoding = \"latin1\")\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                provincia poblacion\n1  Ciudad de Buenos Aires   3121707\n2            Buenos Aires  17523996\n3               Catamarca    429562\n4                   Chaco   1129606\n5                  Chubut    592621\n6                 Córdoba   3840905\n7              Corrientes   1212696\n8              Entre Ríos   1425578\n9                 Formosa    607419\n10                  Jujuy    811611\n11               La Pampa    361859\n12               La Rioja    383865\n13                Mendoza   2043540\n14               Misiones   1278873\n15                Neuquén    710814\n16              Río Negro    750768\n17                  Salta   1441351\n18               San Juan    822853\n19               San Luis    542069\n20             Santa Cruz    337226\n21               Santa Fe   3544908\n22    Santiago del Estero   1060906\n23       Tierra del Fuego    185732\n24                Tucumán   1731820\n```\n\n\n:::\n:::\n\n\n\n## Podemos vincularla con los datos espaciales\n\nPara vincularla necesitamos un campo en común\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg <- merge(arg, d, \n             by.x = \"NAME_1\", \n             by.y = \"provincia\")\narg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 24, 13  (geometries, attributes)\n extent      : -73.56056, -53.59184, -55.06153, -21.78137  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :       NAME_1   GID_1 GID_0   COUNTRY       VARNAME_1 NL_NAME_1\n type        :        <chr>   <chr> <chr>     <chr>           <chr>     <chr>\n values      : Buenos Aires ARG.1_1   ARG Argentina Baires|Buenos ~        NA\n                  Catamarca ARG.2_1   ARG Argentina              NA        NA\n                      Chaco ARG.3_1   ARG Argentina El Chaco|Presi~        NA\n    TYPE_1 ENGTYPE_1  CC_1 HASC_1 (and 3 more)\n     <chr>     <chr> <chr>  <chr>             \n Provincia  Province    NA  AR.BA             \n Provincia  Province    NA  AR.CT             \n Provincia  Province    NA  AR.CC             \n```\n\n\n:::\n:::\n\n\n\n## Veamos la población argentina por provincias\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(arg, \"poblacion\", type = \"continuous\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-52-1.png){width=960}\n:::\n:::\n\n\n\n## A veces necesitamos fusionar las formas de varios polígonos (o líneas) en uno de mayor tamaño\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_0 <- aggregate(arg, by = \"COUNTRY\") \nplot(arg_0, col = \"white\", lwd = 2, border = \"cyan\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-53-1.png){width=960}\n:::\n:::\n\n\n\n## Los objetos ráster también se pueden agregar\n\n:::{.callout-note}\nLa agregación aquí trabaja a nivel de píxel, por lo que se usan para cambiar la resolución de los datos.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2-5\"}\ntavg_10 <- aggregate(tavg, fact = 100, fun = \"mean\", na.rm = TRUE)\npar(mfrow = c(1, 2))\nplot(tavg[[1]])\nplot(tavg_10[[1]])\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-54-1.png){width=960}\n:::\n:::\n\n\n\n## Podemos usar una capa vectorial como máscara para seleccionar objetos dentro de otra capa vectorial\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2|3|4-5\"}\nclip <- rast(ext = c(-70, -60, -47, -30), nrow = 2, ncol = 2)\nvalues(clip) <- 1:4\nnames(clip) <- \"Zona\"\nclip <- as.polygons(clip)\nclip \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 4, 1  (geometries, attributes)\n extent      : -70, -60, -47, -30  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (CRS84) (OGC:CRS84) \n names       :  Zona\n type        : <int>\n values      :     1\n                   2\n                   3\n```\n\n\n:::\n:::\n\n\n\n## Veamos que aspecto presentan las dos capas\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(arg) \nplot(clip, add = TRUE, border = \"blue\", lwd = 5) \n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-56-1.png){width=960}\n:::\n:::\n\n\n \n## Hagamos la intersección y veamos el resultado\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_clip <- intersect(arg, clip) \nplot(arg_clip)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-57-1.png){width=960}\n:::\n:::\n\n\n\n## Los objetos ráster también se pueden cortar con un vectorial\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntavg_arg <- mask(tavg, arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nplot(tavg[[1]])\nplot(tavg_arg[[1]])\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-58-1.png){width=960}\n:::\n:::\n\n\n\n## Otras veces necesitamos combinar las formas de dos objetos vectoriales diferentes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- union(arg, clip)\nplot(u, col = sample(rainbow(length(u))))\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-59-1.png){width=960}\n:::\n:::\n\n\n\n## Es muy útil extraer información de una capa vectorial en los puntos, líneas o polígonos de otra capa vectorial\n\nPara ello creamos una capa de puntos cualquiera\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnts <- spatSample(arg, 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(arg)\nplot(clip, add = TRUE, border = \"cyan\")\nplot(pnts, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-61-1.png){width=960}\n:::\n:::\n\n\n\n## Veamos los valores de las capas en los puntos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnts_arg <- extract(arg, pnts)\nhead(pnts_arg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id.y       NAME_1    GID_1 GID_0   COUNTRY           VARNAME_1 NL_NAME_1\n1    1     San Luis ARG.19_1   ARG Argentina                <NA>      <NA>\n2    2    Río Negro ARG.16_1   ARG Argentina                <NA>      <NA>\n3    3     La Pampa ARG.11_1   ARG Argentina  El Pampa|Eva Perón      <NA>\n4    4     San Juan ARG.18_1   ARG Argentina                <NA>      <NA>\n5    5   Santa Cruz ARG.20_1   ARG Argentina                <NA>      <NA>\n6    6 Buenos Aires  ARG.1_1   ARG Argentina Baires|Buenos Ayres      <NA>\n     TYPE_1 ENGTYPE_1 CC_1 HASC_1 ISO_1 perimetro poblacion\n1 Provincia  Province <NA>  AR.SL  AR-D   1379291    542069\n2 Provincia  Province <NA>  AR.RN  <NA>   2829645    750768\n3 Provincia  Province <NA>  AR.LP  AR-L   1816742    361859\n4 Provincia  Province <NA>  AR.SJ  AR-J   1897254    822853\n5 Provincia  Province <NA>  AR.SC  AR-Z   3552444    337226\n6 Provincia  Province <NA>  AR.BA  AR-B   6542993  17523996\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npnts_clip <- extract(clip, pnts)\nhead(pnts_clip)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id.y Zona\n1    1    1\n2    2    3\n3    3    2\n4    4    1\n5    5   NA\n6    6    2\n```\n\n\n:::\n:::\n\n\n\n## Igual podemos hacer con respecto a los valores de los píxeles en cada punto de un vectorial\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnts_tavg <- extract(tavg, pnts)\nhead(pnts_tavg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID ARG_wc2.1_30s_tavg_1 ARG_wc2.1_30s_tavg_2 ARG_wc2.1_30s_tavg_3\n1  1                 24.3                 22.8                 19.9\n2  2                 19.9                 18.9                 15.9\n3  3                 23.9                 22.5                 19.4\n4  4                 24.7                 23.5                 20.9\n5  5                 17.0                 16.4                 14.1\n6  6                 23.8                 22.6                 19.2\n  ARG_wc2.1_30s_tavg_4 ARG_wc2.1_30s_tavg_5 ARG_wc2.1_30s_tavg_6\n1                 15.8                 11.5                  7.9\n2                 11.1                  7.4                  4.2\n3                 15.2                 11.0                  7.8\n4                 16.3                 12.1                  8.5\n5                 10.7                  6.7                  3.8\n6                 15.5                 11.7                  8.6\n  ARG_wc2.1_30s_tavg_7 ARG_wc2.1_30s_tavg_8 ARG_wc2.1_30s_tavg_9\n1                  7.4                  9.6                 12.8\n2                  3.9                  5.9                  8.4\n3                  7.5                  9.5                 12.6\n4                  8.1                 10.6                 13.9\n5                  3.7                  5.9                  8.3\n6                  8.1                  9.7                 12.6\n  ARG_wc2.1_30s_tavg_10 ARG_wc2.1_30s_tavg_11 ARG_wc2.1_30s_tavg_12\n1                  17.2                  20.6                  23.5\n2                  12.2                  16.0                  18.7\n3                  16.1                  19.6                  22.8\n4                  18.1                  21.5                  24.1\n5                  11.3                  14.2                  15.7\n6                  16.0                  19.8                  22.8\n```\n\n\n:::\n:::\n\n\n\n:::{.callout-warning}\nFijaros que extrae un valor de cada capa del ráster stack\n:::\n\n## También funciona con polígonos\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2\"}\nprov_tavg <- extract(tavg, arg, fun = \"mean\", bind = TRUE, na.rm = TRUE)\nplot(prov_tavg, \"ARG_wc2.1_30s_tavg_1\")\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-65-1.png){width=960}\n:::\n:::\n\n\n\n## Los objetos ráster se puede operar matemáticamente con ellos para generar estadísticos\n\n`min`, `max`, `mean`, `prod`, `sum`, `median`, `cv`, `range`, `any` y `all`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_tavg <- min(tavg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n|---------|---------|---------|---------|\n=========================================\n                                          \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(min_tavg)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-66-1.png){width=960}\n:::\n:::\n\n\n\n## También hay multitud de funciones avanzadas propias de un SIG, tanto para vectoriales como ráster\n\n`crop`, `trim`, `merge`, `disagg`, `resample`, `classify` o `cover`\n\nEl paquete `gdistance` ofrece análisis de distancias complejos (least cost path, etcétera)\n\n## *Last but not least!* Se pueden transformar datos vectoriales en ráster...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narg_raster <- rasterize(arg, tavg, field = \"NAME_1\")\nclass(arg_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(arg_raster)\n```\n\n::: {.cell-output-display}\n![](AEMER-2-Presentación_files/figure-revealjs/unnamed-chunk-67-1.png){width=960}\n:::\n:::\n\n\n\n## ... y viceversa\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.polygons(tavg[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 41, 1  (geometries, attributes)\n extent      : -74, -53.5, -55.5, -21.5  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : ARG_wc2.1_30s_tavg_1\n type        :                <int>\n values      :                  -11\n                                -10\n                                 -9\n```\n\n\n:::\n:::\n\n\n\n## Hora de trabajar por vuestra cuenta...\n\nEjercicios de clase\n\nParte 3. Manipulación de datos ráster y vectoriales\n",
    "supporting": [
      "AEMER-2-Presentación_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}